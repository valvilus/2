import {
  __commonJS,
  __require
} from "./chunk-SNAQBZPT.js";

// node_modules/crypt/crypt.js
var require_crypt = __commonJS({
  "node_modules/crypt/crypt.js"(exports, module) {
    (function() {
      var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
        // Bit-wise rotation left
        rotl: function(n, b) {
          return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n, b) {
          return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
          if (n.constructor == Number) {
            return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
          }
          for (var i = 0; i < n.length; i++)
            n[i] = crypt.endian(n[i]);
          return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n) {
          for (var bytes = []; n > 0; n--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
            words[b >>> 5] |= bytes[i] << 24 - b % 32;
          return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8)
            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
          return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 15).toString(16));
          }
          return hex.join("");
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
          for (var bytes = [], c = 0; c < hex.length; c += 2)
            bytes.push(parseInt(hex.substr(c, 2), 16));
          return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
            for (var j = 0; j < 4; j++)
              if (i * 8 + j * 6 <= bytes.length * 8)
                base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
              else
                base64.push("=");
          }
          return base64.join("");
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
          for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
            if (imod4 == 0) continue;
            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
          }
          return bytes;
        }
      };
      module.exports = crypt;
    })();
  }
});

// node_modules/charenc/charenc.js
var require_charenc = __commonJS({
  "node_modules/charenc/charenc.js"(exports, module) {
    var charenc = {
      // UTF-8 encoding
      utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },
      // Binary encoding
      bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          for (var bytes = [], i = 0; i < str.length; i++)
            bytes.push(str.charCodeAt(i) & 255);
          return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          for (var str = [], i = 0; i < bytes.length; i++)
            str.push(String.fromCharCode(bytes[i]));
          return str.join("");
        }
      }
    };
    module.exports = charenc;
  }
});

// node_modules/sha1/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha1/sha1.js"(exports, module) {
    (function() {
      var crypt = require_crypt(), utf8 = require_charenc().utf8, bin = require_charenc().bin, sha1 = function(message) {
        if (message.constructor == String)
          message = utf8.stringToBytes(message);
        else if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message))
          message = message.toString();
        var m = crypt.bytesToWords(message), l = message.length * 8, w = [], H0 = 1732584193, H1 = -271733879, H2 = -1732584194, H3 = 271733878, H4 = -1009589776;
        m[l >> 5] |= 128 << 24 - l % 32;
        m[(l + 64 >>> 9 << 4) + 15] = l;
        for (var i = 0; i < m.length; i += 16) {
          var a = H0, b = H1, c = H2, d = H3, e = H4;
          for (var j = 0; j < 80; j++) {
            if (j < 16)
              w[j] = m[i + j];
            else {
              var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
              w[j] = n << 1 | n >>> 31;
            }
            var t = (H0 << 5 | H0 >>> 27) + H4 + (w[j] >>> 0) + (j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 : j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 : j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 : (H1 ^ H2 ^ H3) - 899497514);
            H4 = H3;
            H3 = H2;
            H2 = H1 << 30 | H1 >>> 2;
            H1 = H0;
            H0 = t;
          }
          H0 += a;
          H1 += b;
          H2 += c;
          H3 += d;
          H4 += e;
        }
        return [H0, H1, H2, H3, H4];
      }, api = function(message, options) {
        var digestbytes = crypt.wordsToBytes(sha1(message));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
      };
      api._blocksize = 16;
      api._digestsize = 20;
      module.exports = api;
    })();
  }
});

// node_modules/nominatim-geocoder/model/Query.js
var require_Query = __commonJS({
  "node_modules/nominatim-geocoder/model/Query.js"(exports, module) {
    var sha1 = require_sha1();
    var Query = class {
      hash() {
        return sha1(JSON.stringify(this));
      }
      // Axios needs a plain object
      plainObject() {
        return JSON.parse(JSON.stringify(this));
      }
    };
    module.exports = Query;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.replace(/^\s*/, "").replace(/\s*$/, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object" && !isArray(obj)) {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === "object" && typeof val === "object") {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      return error;
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          }
          if (!utils.isArray(val)) {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/btoa.js
var require_btoa = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/btoa.js"(exports, module) {
    "use strict";
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function E() {
      this.message = "String contains an invalid character";
    }
    E.prototype = new Error();
    E.prototype.code = 5;
    E.prototype.name = "InvalidCharacterError";
    function btoa(input) {
      var str = String(input);
      var output = "";
      for (
        var block, charCode, idx = 0, map = chars;
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = "=", idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3 / 4);
        if (charCode > 255) {
          throw new E();
        }
        block = block << 8 | charCode;
      }
      return output;
    }
    module.exports = btoa;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var buildURL = require_buildURL();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var btoa = typeof window !== "undefined" && window.btoa && window.btoa.bind(window) || require_btoa();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        var loadEvent = "onreadystatechange";
        var xDomain = false;
        if (typeof window !== "undefined" && window.XDomainRequest && !("withCredentials" in request) && !isURLSameOrigin(config.url)) {
          request = new window.XDomainRequest();
          loadEvent = "onload";
          xDomain = true;
          request.onprogress = function handleProgress() {
          };
          request.ontimeout = function handleTimeout() {
          };
        }
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        request[loadEvent] = function handleLoad() {
          if (!request || request.readyState !== 4 && !xDomain) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
          var response = {
            data: responseData,
            // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
            status: request.status === 1223 ? 204 : request.status,
            statusText: request.status === 1223 ? "No Content" : request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve, reject, response);
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          reject(createError(
            "timeout of " + config.timeout + "ms exceeded",
            config,
            "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var cookies = require_cookies();
          var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (config.withCredentials) {
          request.withCredentials = true;
        }
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            if (config.responseType !== "json") {
              throw e;
            }
          }
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (requestData === void 0) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined") {
        adapter = require_xhr();
      }
      return adapter;
    }
    var defaults = {
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, "application/json;charset=utf-8");
          return JSON.stringify(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (e) {
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled,
        rejected
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function transformData(data, headers, fns) {
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });
      return data;
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers || {}
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var defaults = require_defaults();
    var utils = require_utils();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = utils.merge({
          url: arguments[0]
        }, arguments[1]);
      }
      config = utils.merge(defaults, this.defaults, { method: "get" }, config);
      config.method = config.method.toLowerCase();
      if (config.baseURL && !isAbsoluteURL(config.url)) {
        config.url = combineURLs(config.baseURL, config.url);
      }
      var chain = [dispatchRequest, void 0];
      var promise = Promise.resolve(config);
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method,
          url
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(utils.merge(defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/nominatim-geocoder/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/nominatim-geocoder/node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/lru/index.js
var require_lru = __commonJS({
  "node_modules/lru/index.js"(exports, module) {
    var events = require_events();
    var inherits = require_inherits_browser();
    module.exports = LRU;
    function LRU(opts) {
      if (!(this instanceof LRU)) return new LRU(opts);
      if (typeof opts === "number") opts = { max: opts };
      if (!opts) opts = {};
      events.EventEmitter.call(this);
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
      this.max = opts.max || 1e3;
      this.maxAge = opts.maxAge || 0;
    }
    inherits(LRU, events.EventEmitter);
    Object.defineProperty(LRU.prototype, "keys", {
      get: function() {
        return Object.keys(this.cache);
      }
    });
    LRU.prototype.clear = function() {
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
    };
    LRU.prototype.remove = function(key) {
      if (typeof key !== "string") key = "" + key;
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      delete this.cache[key];
      this._unlink(key, element.prev, element.next);
      return element.value;
    };
    LRU.prototype._unlink = function(key, prev, next) {
      this.length--;
      if (this.length === 0) {
        this.head = this.tail = null;
      } else {
        if (this.head === key) {
          this.head = prev;
          this.cache[this.head].next = null;
        } else if (this.tail === key) {
          this.tail = next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[prev].next = next;
          this.cache[next].prev = prev;
        }
      }
    };
    LRU.prototype.peek = function(key) {
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      if (!this._checkAge(key, element)) return;
      return element.value;
    };
    LRU.prototype.set = function(key, value) {
      if (typeof key !== "string") key = "" + key;
      var element;
      if (this.cache.hasOwnProperty(key)) {
        element = this.cache[key];
        element.value = value;
        if (this.maxAge) element.modified = Date.now();
        if (key === this.head) return value;
        this._unlink(key, element.prev, element.next);
      } else {
        element = { value, modified: 0, next: null, prev: null };
        if (this.maxAge) element.modified = Date.now();
        this.cache[key] = element;
        if (this.length === this.max) this.evict();
      }
      this.length++;
      element.next = null;
      element.prev = this.head;
      if (this.head) this.cache[this.head].next = key;
      this.head = key;
      if (!this.tail) this.tail = key;
      return value;
    };
    LRU.prototype._checkAge = function(key, element) {
      if (this.maxAge && Date.now() - element.modified > this.maxAge) {
        this.remove(key);
        this.emit("evict", { key, value: element.value });
        return false;
      }
      return true;
    };
    LRU.prototype.get = function(key) {
      if (typeof key !== "string") key = "" + key;
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      if (!this._checkAge(key, element)) return;
      if (this.head !== key) {
        if (key === this.tail) {
          this.tail = element.next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[element.prev].next = element.next;
        }
        this.cache[element.next].prev = element.prev;
        this.cache[this.head].next = key;
        element.prev = this.head;
        element.next = null;
        this.head = key;
      }
      return element.value;
    };
    LRU.prototype.evict = function() {
      if (!this.tail) return;
      var key = this.tail;
      var value = this.remove(this.tail);
      this.emit("evict", { key, value });
    };
  }
});

// node_modules/promise-queue/lib-cov/index.js
var require_lib_cov = __commonJS({
  "node_modules/promise-queue/lib-cov/index.js"() {
  }
});

// node_modules/promise-queue/lib/index.js
var require_lib = __commonJS({
  "node_modules/promise-queue/lib/index.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports && typeof __require === "function") {
        module.exports = factory();
      } else if (typeof define === "function" && typeof define.amd === "object") {
        define(factory);
      } else {
        root.Queue = factory();
      }
    })(exports, function() {
      "use strict";
      var LocalPromise = typeof Promise !== "undefined" ? Promise : function() {
        return {
          then: function() {
            throw new Error("Queue.configure() before use Queue");
          }
        };
      };
      var noop = function() {
      };
      var resolveWith = function(value) {
        if (value && typeof value.then === "function") {
          return value;
        }
        return new LocalPromise(function(resolve) {
          resolve(value);
        });
      };
      function Queue(maxPendingPromises, maxQueuedPromises, options) {
        this.options = options = options || {};
        this.pendingPromises = 0;
        this.maxPendingPromises = typeof maxPendingPromises !== "undefined" ? maxPendingPromises : Infinity;
        this.maxQueuedPromises = typeof maxQueuedPromises !== "undefined" ? maxQueuedPromises : Infinity;
        this.queue = [];
      }
      Queue.configure = function(GlobalPromise) {
        LocalPromise = GlobalPromise;
      };
      Queue.prototype.add = function(promiseGenerator) {
        var self = this;
        return new LocalPromise(function(resolve, reject, notify) {
          if (self.queue.length >= self.maxQueuedPromises) {
            reject(new Error("Queue limit reached"));
            return;
          }
          self.queue.push({
            promiseGenerator,
            resolve,
            reject,
            notify: notify || noop
          });
          self._dequeue();
        });
      };
      Queue.prototype.getPendingLength = function() {
        return this.pendingPromises;
      };
      Queue.prototype.getQueueLength = function() {
        return this.queue.length;
      };
      Queue.prototype._dequeue = function() {
        var self = this;
        if (this.pendingPromises >= this.maxPendingPromises) {
          return false;
        }
        var item = this.queue.shift();
        if (!item) {
          if (this.options.onEmpty) {
            this.options.onEmpty();
          }
          return false;
        }
        try {
          this.pendingPromises++;
          resolveWith(item.promiseGenerator()).then(function(value) {
            self.pendingPromises--;
            item.resolve(value);
            self._dequeue();
          }, function(err) {
            self.pendingPromises--;
            item.reject(err);
            self._dequeue();
          }, function(message) {
            item.notify(message);
          });
        } catch (err) {
          self.pendingPromises--;
          item.reject(err);
          self._dequeue();
        }
        return true;
      };
      return Queue;
    });
  }
});

// node_modules/promise-queue/index.js
var require_promise_queue = __commonJS({
  "node_modules/promise-queue/index.js"(exports, module) {
    module.exports = process.env.PROMISE_QUEUE_COVERAGE ? require_lib_cov() : require_lib();
  }
});

// node_modules/nominatim-geocoder/index.js
var require_nominatim_geocoder = __commonJS({
  "node_modules/nominatim-geocoder/index.js"(exports, module) {
    var Query = require_Query();
    var axios = require_axios2();
    var Cache = require_lru();
    var Queue = require_promise_queue();
    var defaultConcurrency = 1;
    var defaultMaxQueueLength = Infinity;
    var cacheSize = 1e5;
    var SingletonContext = {
      queue: new Queue(defaultConcurrency, defaultMaxQueueLength),
      cache: new Cache(cacheSize)
    };
    var Nominatim = class {
      constructor(options, queryOptions) {
        const defaultOptions = {
          secure: false,
          // enables ssl
          host: "nominatim.openstreetmap.org",
          customUrl: void 0,
          // if you want to host your own nominatim
          cache: true,
          delay: 1e3
          // Delay between requests
        };
        const queryDefaults = {
          format: "json",
          limit: 3
        };
        this.options = Object.assign({}, defaultOptions, options);
        this.queryDefaults = Object.assign({}, queryDefaults, queryOptions);
      }
      static setupCache(size) {
        if (SingletonContext.cache) {
          SingletonContext.cache.clear();
        }
        SingletonContext.cache = new Cache(size);
      }
      static setupQueue(concurrency, maxQueueLength) {
        SingletonContext.queue = new Queue(
          concurrency || defaultConcurrency,
          maxQueueLength || defaultMaxQueueLength
        );
      }
      protocol(options) {
        return options.secure ? "https" : "http";
      }
      buildUrl(options, slug) {
        if (options.customUrl) {
          return options.customUrl + slug;
        }
        return this.protocol(options) + "://" + options.host + slug;
      }
      search(query, options) {
        const opt = Object.assign({}, this.options, options);
        const url = this.buildUrl(opt, "/search");
        return this.query(url, query);
      }
      reverse(query, options) {
        const opt = Object.assign({}, this.options, options);
        const url = this.buildUrl(opt, "/reverse");
        return this.query(url, query);
      }
      query(url, query) {
        const queryObject = Object.assign(new Query(), this.queryDefaults, query);
        const cacheHitInformation = { hit: false };
        return SingletonContext.queue.add(() => {
          const promise = new Promise((resolve, reject) => {
            let cachedResponse;
            if (cachedResponse = SingletonContext.cache.get(queryObject.hash())) {
              cacheHitInformation.hit = true;
              resolve(cachedResponse);
              return;
            }
            axios.get(url, { params: queryObject.plainObject() }).then((response) => {
              resolve(response.data);
            }).catch((error) => {
              SingletonContext.cache.remove(queryObject.hash());
              reject(error);
            });
          });
          const delayedPromise = this.delayPromise(promise, cacheHitInformation);
          SingletonContext.cache.set(queryObject.hash(), delayedPromise);
          return delayedPromise;
        });
      }
      // This method wraps a promise, it waits after a promise is resolved/rejected
      // and resolves the outer promise when the remaing time after delayBetweenRequests
      // has passed. Quite a hack...
      // ToDo: Replace
      // Note: Rate limiting is subject to the jasmine tests
      delayPromise(promise, cacheHitInformation) {
        const start = /* @__PURE__ */ new Date();
        const handleEndedPromise = (action, responseOrError) => {
          const end = /* @__PURE__ */ new Date();
          const timeToWait = this.options.delay - (end - start);
          const isFromCache = cacheHitInformation.hit;
          if (timeToWait > 0 && !isFromCache) {
            setTimeout(() => action(responseOrError), timeToWait);
          } else {
            action(responseOrError);
          }
        };
        return new Promise((resolve, reject) => {
          promise.then((response, query, test) => {
            handleEndedPromise(resolve, response);
          }).catch((error, query) => {
            handleEndedPromise(reject, error);
          });
        });
      }
    };
    var NominatimCallbackWrapper = class extends Nominatim {
      search(query, options, callback) {
        const promise = super.search(query, options);
        return this.handlePromise(promise, callback);
      }
      reverse(query, options, callback) {
        const promise = super.reverse(query, options);
        return this.handlePromise(promise, callback);
      }
      handlePromise(promise, callback) {
        if (typeof callback === "function") {
          return this.wrapPromiseWithCallback(promise, callback);
        }
        return promise;
      }
      wrapPromiseWithCallback(promise, callback) {
        return promise.then((data, query) => callback(void 0, data)).catch((error, query) => callback(error, void 0));
      }
    };
    Nominatim.Nominatim = Nominatim;
    Nominatim.NominatimCallback = NominatimCallbackWrapper;
    Nominatim.NominatimSingletonContext = SingletonContext;
    Nominatim.NominatimCache = Cache;
    Nominatim.NominatimQueue = Queue;
    module.exports = Nominatim;
  }
});
export default require_nominatim_geocoder();
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=nominatim-geocoder.js.map
